#!/usr/bin/perl

=head1 NAME

git-list-pr - A tool to list GitHub pull requests and choose one to checkout optionally

=head1 SYNOPSIS

    # print all active PRs
    git list-pr

    # launch fzf and choose one to checkout
    git list-pr -c

=head1 DESCRIPTION

This script uses the GitHub CLI (C<gh>) to retrieve a list of pull requests for
the current repository. If formats and displays the list with color-coded
output. Optionally it allows to the user to select one interactively using
C<fzf> and check it out.

=head1 OPTIONS

=over 4

=item B<-c>, B<--checkout>

Use C<fzf> to select a pull request to checkout interactively. Requires C<fzf>
to be installed.

Supply additional options to C<fzf>. The default is empty.

=item B<-r>, B<--recurse-submodules>

When checking out a pull request, also checkout its submodules recursively.

=item B<-s>, B<--search-options>=I<options>

This will be used to filter the pull requests. It is passed directly to
C<gh pr list>.

=item B<-w>, B<--web>

Open the selected pull request in the web browser instead of checking it out.

=item B<-h>, B<--help>

Show this help message.

=back

=cut

use 5.34.0;
use warnings;
use feature 'signatures';
no warnings 'experimental::signatures';
use utf8;
use File::Which qw(which);
use Getopt::Long qw(:config posix_default no_ignore_case bundling auto_help);
use JSON;
use Path::Tiny qw(path);
use Pod::Usage qw(pod2usage);
use Term::ANSIColor qw(:constants);
use Time::Piece;
use List::Util qw(max reduce);
binmode STDERR, ":utf8";
binmode STDOUT, ":utf8";

my %opt = (
    'fzf-options' => '',
    'search-options' => '',
);
GetOptions(
    \%opt, qw(
    checkout|c
    fzf-options|f=s
    recurse-submodules|r
    search-options|s=s
    web|w
    help|h
)) or pod2usage(1);
$opt{help} and pod2usage(0);
which 'git' or pod2usage({ -message => 'git not found', -exitval => 2});
which 'gh' or pod2usage({ -message => 'gh not found', -exitval => 2});
which 'fzf' or pod2usage({ -message => 'fzf not found', -exitval => 2}) if $opt{checkout};

my $decoded = eval { decode_json `gh pr list $opt{'search-options'} --json number,title,headRefName,author,createdAt,isDraft` };
if ($@) {
    warn "Failed to decode JSON: $@";
    exit 1;
}

my $emoji = eval {
    my $cache_file = '/tmp/github_emoji.json';
    if (-e $cache_file) {
        decode_json path($cache_file)->slurp;
    } else {
        my $json = decode_json `gh api -H 'Accept: application/vnd.github.v3+json' /emojis`;
        for (keys $json->%*) {
            $json->{$_} =~ s|.*/([-\da-f]+)\.png.*|
                join '', map { chr hex } split /-/, $1;
            |e;
        }
        path($cache_file)->spew(encode_json $json);
        $json;
    }
};
die "Failed to load emojis: $@" if $@;

sub default_branches {
    map {
        my $epoch = (split /\n/, `git log origin/$_ --reverse --pretty=format:'%ct'`)[0];
        {
            author => { login => 'system' },
            createdAt => gmtime($epoch)->strftime('%FT%TZ'),
            headRefName => $_,
            isDraft => 0,
            number => 0,
            title => $_,
        }
    } sort map { s,.*origin/,,; $_ } grep {
        m,^  origin/(?:main|master|develop|staging)$,
    } split /\n/, `git branch -r`;
}

my @prs = ($decoded->@*, default_branches);

sub fmt($name) {
    my @char_counts = map {
        my %count;
        for (split //, $_->{$name}) {
            if (/\p{EA=W}/) {
                $count{len} += 2;
                $count{W}++;
            } else {
                $count{len} ++;
            }
        }
        \%count;
    } @prs;

    my $max_length = max map { $_->{len} } @char_counts;

    for my $i (0 .. @char_counts - 1) {
        my $formatted = sprintf "%-${max_length}s", $prs[$i]{$name};
        $prs[$i]{formatted}{$name} = $char_counts[$i]{W} ? substr $formatted, 0, - $char_counts[$i]{W} : $formatted;
    }
}

for (@prs) {
    $_->{title} =~ s|:(\w+):|$emoji->{$1} // $&|eg;
    $_->{authorName} = $_->{author}{login} // 'unknown';
}

fmt('title');
fmt('headRefName');
fmt('authorName');

my $result = reduce {
    $a .
    ($b->{isDraft} ? BRIGHT_BLACK : GREEN) .
    sprintf('#%-4d  ', $b->{number}) .
    RESET .
    MAGENTA "$b->{formatted}{authorName}  " .
    RESET .
    "$b->{formatted}{title}  " .
    CYAN "$b->{formatted}{headRefName}  " .
    RESET .
    BRIGHT_BLACK "$b->{createdAt}" .
    RESET .
    "\n"
} '', @prs;

if (!$opt{checkout}) {
    print $result;
    exit;
}

my $temp = Path::Tiny->tempfile;
$temp->spew_utf8($result);
my $fzf_opts = $opt{'fzf-options'} =~ /--ansi/  ? $opt{'fzf-options'} : "--ansi $opt{'fzf-options'}";
my $selected = `bash -c "cat $temp | fzf $fzf_opts"`;
if ($? != 0) {
    die "cancelled\n";
    exit $?;
}
my ($num, $ref) = $selected =~ /^#(\d+).*\s+(\S+)\s+\d{4}-\d\d-\d\dT\d\d:\d\d:\d\dZ$/;
if ($num == 0) {
    exec 'sh', '-c', "git checkout $ref && git pull origin $ref && git submodule update --init --recursive";
} elsif ($opt{web}) {
    exec 'gh', 'pr', 'view', '-w', $num;
} else {
    exec 'gh', 'co', ($opt{'recurse-submodules'} ? '--recurse-submodules' : ()), $num;
}
